#' Function to select GCMs
#' 
#' This function follows Amber Runyon's code and Lawrence et al. 2021 to select GCMs for a given park
#' 
#' 
#' @param park Four digit park code
#' @param region Park region to use for selecting low skill models. 3 letter code (capitatlized)
#' @param future_range Range of future years to summarize means for. Two years separated by ":"
#' @param historic_range Range of historic years to summarize means for. Two years separated by ":"
#' @param low_skill_cutoff A percentage (in decimal form) for removing low skill models
#' @param method  The method to use for GCM selection; either 'corners' or 'pca'
#' @param path  The path to the desired data/ folder
#'
#' @return A dataframe with the selected GCMs and assigned climate futures for all centroids within park
#' 
#' 
select_GCMs <-
  function(park,
           region = "mean",
           future_years = 2035:2065,
           historic_years = 1979:2012,
           low_skill_cutoff = 0.1,
           method = "pca",
           path = "data/") {
    
    # READ IN CENTROID FILES --------
    # download and read in climate centroid files
    get_centroid_climate_data(park = "BRCA", save = FALSE)
    
    ## create list of future and historic dfs
    ## MAKE SURE no other objects with '_future' or '_historical' in their names
    future_dfs <- mget(ls(pattern = "_future"))
    
    historic_dfs <- mget(ls(pattern = "_historical"))
    
    
    # list of CF categories
    CFs_all <- c("Warm Wet", "Hot Wet", "Central", "Warm Dry", "Hot Dry")
    
    # read in low skills models (make sure this file is in 'path')
    low_skill_models <-
      read_delim('data/GCM_skill_by_region.txt') %>%
      filter(if (region %in% Region) {
        Region == region
      } else {
        Region == "mean"
      }) %>%
      # remove period at end of GCM names (will need later)
      mutate(GCM = str_sub(GCM, 1, -2)) %>% 
      # Worse models have higher value rank
      slice_max(n = length(unique(future_all$GCM)) / 2 * Percent_skill_cutoff,
                order_by  = Rank)
    
    
    # ITERATE OVER CENTROIDS -------
    
    for(i in 1:length(future_dfs)) {
    # clean data
    # future data, filter to 2035-2065 (2050 mean)
    future_all <- future_dfs[[i]] %>%
      dplyr::rename(precip_in = `Precip (in)`,
                    tmin_f = `Tmin (F)`,
                    tmax_f = `Tmax (F)`,
                    rhmax = `RHmax (%)`,
                    rhmin = `RHmin(%)`,
                    tavg_f = `Tavg (F)`) %>% 
      mutate(
        year = format(Date, "%Y"),
        #VPD = VPD(tmin_f, tmax_f, rhmin, rhmax), # do we need vapor pressure??
        DOY = yday(Date)
      ) %>% 
      filter(year %in% future_range)
    
    
    # historic data, filter to 1979-2012 baseline
    historic_all <- historic_dfs[[i]] %>%
      dplyr::rename(precip_in = `Precip (in)`,
                    tmin_f = `Tmin (F)`,
                    tmax_f = `Tmax (F)`,
                    rhmax = `RHmax (%)`,
                    rhmin = `RHmin(%)`,
                    tavg_f = `Tavg (F)`) %>% 
      mutate(
        year = format(Date, "%Y"),
        #VPD = VPD(tmin_f, tmax_f, rhmin, rhmax),
        DOY = yday(Date)
      ) %>% 
      filter(year %in% historic_range)
    
 
    
    
    # calculate deltas
    
    # baseline means from historic data
    baseline <- historic_all %>% 
      summarise(baseline_pr = mean(precip_in),
                baseline_tmax = mean(tmax_f),
                baseline_tmin = mean(tmin_f),
                baseline_tavg = mean(tavg_f),
                baseline_rhmax = mean(rhmax),
                baseline_rhmin = mean(rhmin))
    
    
    # future means for each GCM
    future_means <- future_all %>% 
      group_by(GCM) %>% 
      summarise_at(vars(precip_in:tavg_f), mean, na.rm = TRUE) %>% 
      # add delta columns using baseline values
      mutate(delta_pr = precip_in - baseline$baseline_pr,
             delta_tmax = tmax_f - baseline$baseline_tmax,
             delta_tmin = tmin_f - baseline$baseline_tmin,
             delta_tavg = tavg_f - baseline$baseline_tavg,
             delta_rhmax = rhmax - baseline$baseline_rhmax,
             delta_rhmin = rhmin - baseline$baseline_rhmin) %>% 
      # remove low skill models
      separate_wider_delim(GCM, 
                           names = c("GCM_only", "RCP"),
                           delim = ".",
                           cols_remove  = FALSE) %>% 
      filter(!GCM_only %in% low_skill_models$GCM)
    
    # assign climate futures
    
    #### Set limits for CF classification
    Pr0 <-  as.numeric(quantile(future_means$delta_pr, 0))
    Pr25 <-  as.numeric(quantile(future_means$delta_pr, 0.25))
    PrAvg <-  mean(future_means$delta_pr)
    Pr75 <-  as.numeric(quantile(future_means$delta_pr, 0.75))
    Pr100 <-  as.numeric(quantile(future_means$delta_pr, 1))
    Tavg0 <-  as.numeric(quantile(future_means$delta_tavg, 0))
    Tavg25 <-  as.numeric(quantile(future_means$delta_tavg, 0.25)) 
    Tavg <-  mean(future_means$delta_tavg)
    Tavg75 <-  as.numeric(quantile(future_means$delta_tavg, 0.75))
    Tavg100 <-  as.numeric(quantile(future_means$delta_tavg, 1))
    
    # CF assignment
    future_means <- future_means %>%
      # designate climate future classification based on cf limits
      mutate(
        CF = case_when(
          delta_tavg < Tavg &
            delta_pr > Pr75 |
            delta_tavg < Tavg25 & delta_pr > PrAvg ~ "Warm Wet",
          delta_tavg > Tavg &
            delta_pr > Pr75 |
            delta_tavg > Tavg75 & delta_pr > PrAvg ~ "Hot Wet",
          delta_tavg > Tavg25 &
            delta_tavg < Tavg75 &
            delta_pr > Pr25 & delta_pr < Pr75 ~ "Central",
          delta_tavg < Tavg &
            delta_pr < Pr25 |
            delta_tavg < Tavg25 & delta_pr < PrAvg ~ "Warm Dry",
          delta_tavg > Tavg &
            delta_pr < Pr25 |
            delta_tavg > Tavg75 & delta_pr < PrAvg ~ "Hot Dry"
        )
      )
    
    # corners method
    #### Select Corner GCMs, assuming temp on x and precip on y
    lx = min(future_means$delta_tavg)
    ux = max(future_means$delta_tavg)
    ly = min(future_means$delta_pr)
    uy = max(future_means$delta_pr)
    
    #convert to points
    ww = c(lx,uy)
    wd = c(lx,ly)
    hw = c(ux,uy)
    hd = c(ux,ly)
    
    corners <- future_means %>%
      # calculate euclidiean distance of each point/model from each corner
      mutate(
        ww_dist = sqrt((delta_tavg - ww[1]) ^ 2 + (delta_pr - ww[2]) ^ 2),
        wd_dist = sqrt((delta_tavg - wd[1]) ^ 2 + (delta_pr - wd[2]) ^ 2),
        hw_dist = sqrt((delta_tavg - hw[1]) ^ 2 + (delta_pr - hw[2]) ^ 2),
        hd_dist =  sqrt((delta_tavg - hd[1]) ^ 2 + (delta_pr - hd[2]) ^ 2)
      )
    
    
    # assign CF to each selected corner model
    future_means <- future_means %>%
      mutate(
        corners = case_when(
          GCM == filter(corners, CF == "Warm Wet") %>% slice(which.min(ww_dist)) %>% .$GCM ~ "Warm Wet",
          GCM == filter(corners, CF == "Warm Dry") %>% slice(which.min(wd_dist)) %>% .$GCM ~ "Warm Dry",
          GCM == filter(corners, CF == "Hot Wet") %>% slice(which.min(hw_dist)) %>% .$GCM ~ "Hot Wet",
          GCM == filter(corners, CF == "Hot Dry") %>% slice(which.min(hd_dist)) %>% .$GCM ~ "Hot Dry"
          
        )
      )
    
    # PCA method
    # set up for PCA
    future_pca_1 <- future_means %>% 
      dplyr::select(GCM, delta_pr, delta_tavg) %>% 
      # set up for prcomp
      column_to_rownames(var = 'GCM')
    
    
    pca_1 <- prcomp(future_pca_1, center = TRUE, scale. = TRUE) 
    
    # get dataframe
    pca_1_df <- as.data.frame(pca_1$x)
    
    
    #Take the min/max of each of the PCs
    PCs <- pca_1_df %>% 
      filter(PC1 == min(PC1) |
               PC1 == max(PC1) |
               PC2 == min(PC2) |
               PC2 == max(PC2)) %>% 
      rownames_to_column(var = "GCM")
    
    
    
    #Assigns CFs to diagonals
    diagonals <-
      rbind(
        data.frame(CF = CFs_all[c(1, 5)], diagonals = factor("diagonal1")),
        data.frame(CF = CFs_all[c(4, 2)], diagonals = factor("diagonal2"))
      )
    
    
    PCA <-
      future_means %>% filter(GCM %in% PCs$GCM) %>% left_join(diagonals, by = "CF") %>% right_join(PCs, by = "GCM")
    
    # create column with selected pca models
    future_means <- future_means %>%
      mutate(pca = if_else(GCM %in% PCs$GCM,
                           CF,
                           NA))
    
    
    # handle missing CFs
    # function to deal with redundant quadrat
    ID.redundant.gcm <- function(PCA){
      redundant.diag = count(PCA, diagonals)$diagonals[which(count(PCA, diagonals)$n ==
                                                               1)] #ID redundant diagonal
      PC.foul = PCA$PC[which(PCA$diagonals == redundant.diag)] #ID which PC has the redundant diagonal
      PCA$GCM[which(PCA$PC == PC.foul &
                      PCA$GCM != PCA$GCM[which(PCA$diagonals == redundant.diag)])] #ID GCM that is in both the  redundant diagonal and the duplicative PC
    }
    
    #if a quadrant is missing
    if(length(setdiff(CFs_all[CFs_all != "Central"], future_means_test$pca)) > 0) {
      #assign corners selection to that CF
      future_means$pca[which(future_means$corners == setdiff(CFs_all[CFs_all != "Central"], future_means$pca))] = setdiff(CFs_all[CFs_all != "Central"], future_means$pca)
      #If there is a redundant GCM
      if (nrow(PCA[duplicated(PCA$GCM),]) > 0) {
        
        future_means$pca = future_means$pca #Do nothing - otherwise end up with empty quadrant. This line could be removed and make the previous statment inverse but it makes it more confusing what's gonig on that way
      } else {
        future_means$pca[which(future_means$GCM == ID.redundant.gcm(PCA))] = NA #Removes the GCM that is in redundant diagonal
      }
    }
    
    # return table of selected model
    # return selected methods based on method identified in parameters
    selected_gcms <- future_means %>% 
      drop_na(method) %>% 
      dplyr::select(GCM, CF)
    
    
    }
    
    
    # combine and clean
    
    
    
    
  }