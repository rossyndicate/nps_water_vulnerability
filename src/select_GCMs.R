#' Function to select GCMs
#' 
#' This function follows Amber Runyon's code and Lawrence et al. 2021 to select GCMs for a given park
#' 
#' 
#' @param park Four digit park code
#' @param region Park region to use for selecting low skill models. 3 letter code (capitatlized)
#' @param future_range Range of future years to summarize means for. Two years separated by ":"
#' @param historic_range Range of historic years to summarize means for. Two years separated by ":"
#' @param low_skill_cutoff A percentage (in decimal form) for removing low skill models
#' @param method  The method to use for GCM selection; either 'corners' or 'pca'
#' @param save  TRUE/FALSE, whether or not to save the output dataframe
#' @param path  The path to save dataframe to 
#'
#' @return A dataframe with the selected GCMs and assigned climate futures for all centroids within park
#' 
#' 
select_GCMs <-
  function(park,
           region = "mean",
           future_range = 2035:2065,
           historic_range = 1979:2012,
           low_skill_cutoff = 0.1,
           method = "pca",
           save = FALSE,
           path = "data/") {
    # READ IN CENTROID FILES --------
    # download and read in climate centroid files
    get_centroid_climate_data(park = park, save = FALSE)
    
    
    ## create list of future and historic dfs
    ## MAKE SURE no other objects with '_future' or '_historical' in their names
    future_dfs <-
      mget(ls(.GlobalEnv, pattern = "_future"), envir = .GlobalEnv)
    
    historic_dfs <-
      mget(ls(.GlobalEnv, pattern = "_historical"), envir = .GlobalEnv)
    
    
    # list of CF categories
    CFs_all <-
      c("Warm Wet", "Hot Wet", "Central", "Warm Dry", "Hot Dry")
    
    
    # read in low skills models (read .txt file from CCRP GitHub page)
    low_skill_models <-
      read_delim(
        "https://raw.githubusercontent.com/rossyndicate/CCRP_automated_climate_futures/master/data/general/GCM_skill_by_region.txt"
      ) %>%
      filter(if (region %in% Region) {
        Region == region
      } else {
        Region == "mean"
      }) %>%
      # remove period at end of GCM names (will need later)
      mutate(GCM = str_sub(GCM, 1, -2)) %>%
      # Worse models have higher value rank
      slice_max(n = length(unique(future_dfs[[1]]$GCM)) / 2 * low_skill_cutoff,
                order_by  = Rank)
    
    
    # ITERATE OVER CENTROIDS -------
    
    # create empty list to fill
    selected_gcms <- vector("list", length = length(future_dfs))
    
    for (i in 1:length(future_dfs)) {
      # clean data
      ## future data
      future_all <- future_dfs[[i]] %>%
        dplyr::rename(
          precip_in = `Precip (in)`,
          tmin_f = `Tmin (F)`,
          tmax_f = `Tmax (F)`,
          rhmax = `RHmax (%)`,
          rhmin = `RHmin(%)`,
          tavg_f = `Tavg (F)`
        ) %>%
        mutate(year = format(Date, "%Y"),
               #VPD = VPD(tmin_f, tmax_f, rhmin, rhmax), # do we need vapor pressure??
               DOY = yday(Date)) %>%
        filter(year %in% future_range)
      
      
      ## historic data
      historic_all <- historic_dfs[[i]] %>%
        dplyr::rename(
          precip_in = `Precip (in)`,
          tmin_f = `Tmin (F)`,
          tmax_f = `Tmax (F)`,
          rhmax = `RHmax (%)`,
          rhmin = `RHmin(%)`,
          tavg_f = `Tavg (F)`
        ) %>%
        mutate(year = format(Date, "%Y"),
               #VPD = VPD(tmin_f, tmax_f, rhmin, rhmax),
               DOY = yday(Date)) %>%
        filter(year %in% historic_range)
      
      
      
      
      # calculate deltas
      
      # baseline means from historic data
      baseline <- historic_all %>%
        summarise(
          baseline_pr = mean(precip_in),
          baseline_tmax = mean(tmax_f),
          baseline_tmin = mean(tmin_f),
          baseline_tavg = mean(tavg_f),
          baseline_rhmax = mean(rhmax),
          baseline_rhmin = mean(rhmin)
        )
      
      
      # future means for each GCM
      future_means <- future_all %>%
        group_by(GCM) %>%
        summarise_at(vars(precip_in:tavg_f), mean, na.rm = TRUE) %>%
        # add delta columns using baseline values
        mutate(
          delta_pr = precip_in - baseline$baseline_pr,
          delta_tmax = tmax_f - baseline$baseline_tmax,
          delta_tmin = tmin_f - baseline$baseline_tmin,
          delta_tavg = tavg_f - baseline$baseline_tavg,
          delta_rhmax = rhmax - baseline$baseline_rhmax,
          delta_rhmin = rhmin - baseline$baseline_rhmin
        ) %>%
        # remove low skill models
        separate_wider_delim(
          GCM,
          names = c("GCM_only", "RCP"),
          delim = ".",
          cols_remove  = FALSE
        ) %>%
        filter(!GCM_only %in% low_skill_models$GCM)
      
      # assign climate futures
      
      #### Set limits for CF classification
      Pr0 <-  as.numeric(quantile(future_means$delta_pr, 0))
      Pr25 <-  as.numeric(quantile(future_means$delta_pr, 0.25))
      PrAvg <-  mean(future_means$delta_pr)
      Pr75 <-  as.numeric(quantile(future_means$delta_pr, 0.75))
      Pr100 <-  as.numeric(quantile(future_means$delta_pr, 1))
      Tavg0 <-  as.numeric(quantile(future_means$delta_tavg, 0))
      Tavg25 <-
        as.numeric(quantile(future_means$delta_tavg, 0.25))
      Tavg <-  mean(future_means$delta_tavg)
      Tavg75 <-
        as.numeric(quantile(future_means$delta_tavg, 0.75))
      Tavg100 <-
        as.numeric(quantile(future_means$delta_tavg, 1))
      
      # CF assignment
      future_means <- future_means %>%
        # designate climate future classification based on cf limits
        mutate(
          CF = case_when(
            delta_tavg < Tavg &
              delta_pr > Pr75 |
              delta_tavg < Tavg25 &
              delta_pr > PrAvg ~ "Warm Wet",
            delta_tavg > Tavg &
              delta_pr > Pr75 |
              delta_tavg > Tavg75 &
              delta_pr > PrAvg ~ "Hot Wet",
            delta_tavg > Tavg25 &
              delta_tavg < Tavg75 &
              delta_pr > Pr25 & delta_pr < Pr75 ~ "Central",
            delta_tavg < Tavg &
              delta_pr < Pr25 |
              delta_tavg < Tavg25 &
              delta_pr < PrAvg ~ "Warm Dry",
            delta_tavg > Tavg &
              delta_pr < Pr25 |
              delta_tavg > Tavg75 & delta_pr < PrAvg ~ "Hot Dry"
          )
        )
      
      # corners method
      #### Select Corner GCMs, assuming temp on x and precip on y
      lx = min(future_means$delta_tavg)
      ux = max(future_means$delta_tavg)
      ly = min(future_means$delta_pr)
      uy = max(future_means$delta_pr)
      
      #convert to points
      ww = c(lx, uy)
      wd = c(lx, ly)
      hw = c(ux, uy)
      hd = c(ux, ly)
      
      corners <- future_means %>%
        # calculate euclidiean distance of each point/model from each corner
        mutate(
          ww_dist = sqrt((delta_tavg - ww[1]) ^ 2 + (delta_pr - ww[2]) ^ 2),
          wd_dist = sqrt((delta_tavg - wd[1]) ^ 2 + (delta_pr - wd[2]) ^ 2),
          hw_dist = sqrt((delta_tavg - hw[1]) ^ 2 + (delta_pr - hw[2]) ^ 2),
          hd_dist =  sqrt((delta_tavg - hd[1]) ^ 2 + (delta_pr - hd[2]) ^ 2)
        )
      
      
      # assign CF to each selected corner model
      future_means <- future_means %>%
        mutate(
          corners = case_when(
            GCM == filter(corners, CF == "Warm Wet") %>% slice(which.min(ww_dist)) %>% .$GCM ~ "Warm Wet",
            GCM == filter(corners, CF == "Warm Dry") %>% slice(which.min(wd_dist)) %>% .$GCM ~ "Warm Dry",
            GCM == filter(corners, CF == "Hot Wet") %>% slice(which.min(hw_dist)) %>% .$GCM ~ "Hot Wet",
            GCM == filter(corners, CF == "Hot Dry") %>% slice(which.min(hd_dist)) %>% .$GCM ~ "Hot Dry"
            
          )
        )
      
      # PCA method
      # set up for PCA
      future_pca_1 <- future_means %>%
        dplyr::select(GCM, delta_pr, delta_tavg) %>%
        # set up for prcomp
        column_to_rownames(var = 'GCM')
      
      
      pca_1 <-
        prcomp(future_pca_1, center = TRUE, scale. = TRUE)
      
      # get dataframe
      pca_1_df <- as.data.frame(pca_1$x)
      
      
      #Take the min/max of each of the PCs
      PCs <- pca_1_df %>%
        filter(PC1 == min(PC1) |
                 PC1 == max(PC1) |
                 PC2 == min(PC2) |
                 PC2 == max(PC2)) %>%
        rownames_to_column(var = "GCM")
      
      
      
      #Assigns CFs to diagonals
      diagonals <-
        rbind(
          data.frame(CF = CFs_all[c(1, 5)], diagonals = factor("diagonal1")),
          data.frame(CF = CFs_all[c(4, 2)], diagonals = factor("diagonal2"))
        )
      
      
      PCA <-
        future_means %>% filter(GCM %in% PCs$GCM) %>% left_join(diagonals, by = "CF") %>% right_join(PCs, by = "GCM")
      
      # create column with selected pca models
      future_means <- future_means %>%
        mutate(pca = if_else(GCM %in% PCs$GCM,
                             CF,
                             NA))
      
      
      # handle missing CFs
      # function to deal with redundant quadrat
      ID.redundant.gcm <- function(PCA) {
        redundant.diag = count(PCA$diagonals)$x[which(count(PCA$diagonals)$freq ==
                                                        1)] #ID redundant diagonal
        PC.foul = PCA$PC[which(PCA$diagonals == redundant.diag)] #ID which PC has the redundant diagonal
        PCA$GCM[which(PCA$PC == PC.foul &
                        PCA$GCM != PCA$GCM[which(PCA$diagonals == redundant.diag)])] #ID GCM that is in both the  redundant diagonal and the duplicative PC
      }
      
      #if a quadrant is missing
      if (length(setdiff(CFs_all[CFs_all != "Central"], future_means$pca)) > 0) {
        #assign corners selection to that CF
        future_means$pca[which(future_means$corners == setdiff(CFs_all[CFs_all != "Central"], future_means$pca))] = setdiff(CFs_all[CFs_all != "Central"], future_means$pca)
        #If there is a redundant GCM
        if (nrow(PCA[duplicated(PCA$GCM), ]) > 0) {
          future_means$pca = future_means$pca #Do nothing - otherwise end up with empty quadrant. This line could be removed and make the previous statment inverse but it makes it more confusing what's gonig on that way
        } else {
          future_means$pca[which(future_means$GCM == ID.redundant.gcm(PCA))] = NA #Removes the GCM that is in redundant diagonal
        }
      }
      
      # return table of selected model
      # return selected methods based on method identified in parameters
      selected_gcms[[i]] <- future_means %>%
        drop_na(method) %>%
        mutate(park = park, centroid = names(future_dfs[i])) %>%
        dplyr::select(park, centroid, GCM, CF, delta_tavg, delta_pr)
      
      
    }
    
    
    
    # combine and clean
    
    final_df <- bind_rows(selected_gcms)
    
    if (save == TRUE) {
      write_csv(final_df, paste0(path, "/", park, "_selected_gcms.csv"))
    }
    
    # remove env objects for next iteration
    rm(list = ls(.GlobalEnv, pattern = "_future|_historical"),
       envir = .GlobalEnv)
    
    return(final_df)
    
  }